---
title: "Sensitivity_of_MLE_fits"
author: "Tempest McCabe"
date: "11/19/2018"
output: html_document
---

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(kableExtra)
library(MASS)
library(ggridges)
library(RColorBrewer)
```

# read in data

```{r, echo= TRUE, message=FALSE, warning=FALSE}

florida_8_3 <- read.csv("~/Documents/work/Spacial_adj/Data_and_Figures/Florida_8_3_2014dm2.csv", header = TRUE)
florida_8_5 <- read.csv("~/Documents/work/Spacial_adj/Data_and_Figures/Florida_8_5_2014dm2.csv", header = TRUE)
  
oregon_6_2 <- read.csv("~/Documents/work/Spacial_adj/Data_and_Figures/Oregon_6_2_2014dm2.csv", header = TRUE)
oregon_7_1 <-  read.csv("~/Documents/work/Spacial_adj/Data_and_Figures/Oregon_7_1_2014dm2.csv", header = TRUE)
```

# Upper + lower interior/ total ratio Helper functions

These functions provide the bounds on upper and lower interior / total ratios for different numbers of pixels. 

```{r, echo=TRUE, message=FALSE, warning=FALSE}

upper_bound_ratios <- function(x){
  upper <- rep(NA, length(x))
  edge <- rep(NA, length(x))
  interior <- rep(NA, length(x))
  
  ## get edges
  for(i in seq_along(x)){
    smaller_sqrt <- floor(sqrt(x[i]))
    smaller_square <- smaller_sqrt^2
    
    larger_sqrt <- ceiling(sqrt(x[i]))
    
    remainder <- x[i] %% smaller_square
    
    if (remainder > smaller_sqrt){
      edge[i] <- 4 * larger_sqrt
    }
    
    if (remainder <= smaller_sqrt){
      edge[i] <- (2*smaller_sqrt) + 2*(1+smaller_sqrt)
    }
    
    if (remainder == 0){
      edge[i] <- 4 * larger_sqrt
    }
  }
  
  #get interiors
  for (i in seq_along(x)){
    interior[i] <- 4 * x[i]
    interior[i] <- interior[i] - edge[i]
  }
  
  for (i in seq_along(x)){
    if (x[i] == 1){
      upper[i] <- 0
      next  
    }
    if (x[i] == 2){
      upper[i] <- 0.25
      next
    }
    if (x[i] == 3){
      upper[i] <- 0.5
      next 
    }
    
    upper[i] <- interior[i] / (interior[i] + edge[i])
  }
  
  
  return(upper)
}

lower_bound_ratios <- function(x){
  lower <- rep(NA, length(x))
  edge <- rep(NA, length(x))
  interior <- rep(NA, length(x))
  
  for (i in seq_along(x)){
    if(x[i] == 1){
      edge[i] <- 4
      next
    }
    
    if (x[i] == 2){
      edge[i] <- 6  
      next
    }
    
      edge[i] <- (2 * (x[i] - 2)) + 6 # The six accounts for sides of the two end pixels 
  }
  
  for (i in seq_along(x)){
    if(x[i] == 1){
    interior[i] <- 0
     lower[i] <- interior[i] / (interior[i] + edge[i])
      next
    }
    
    if (x[i] == 2){
     interior[i] <- 2
      lower[i] <- interior[i] / (interior[i] + edge[i])
      next
    }
    
     interior[i] <- ((4 * x[i]) - edge[i])
     lower[i] <- interior[i] / (interior[i] + edge[i])
  }
  return (lower)
}


```

# Sifting out edge-cases with artificial ratio inflation

The base raster adjacency function that we used when calculating interior/total ratios made a wrap-around adjacency assumption, inflating the adjacency of corner and edge pixels. We corrected for it by setting ratios above the maximum to NA. 

```{r, echo=TRUE, message=FALSE, warning=FALSE}
oregon_6_2$eco_II <- "6.2"  ## Put in Ecoregion labels 
oregon_7_1$eco_II <- "7.1"
florida_8_3$eco_II <- "8.3"
florida_8_5$eco_II <- "8.5"

florida <- rbind(florida_8_3, florida_8_5) 
oregon <- rbind(oregon_6_2, oregon_7_1)

florida$size_ha <- florida$sizw * 0.09  ## Convert Pixels to ha
oregon$size_ha <- oregon$sizw * 0.09

florida$state <- "FL"  ## State Labels 
oregon$state <- "OR"
final <- rbind(florida, oregon)


final$ratio[(final$ratio > 0.25) & (final$sizw == 2)] <- NA
final$ratio[(final$ratio > 0.33) & (final$sizw == 3)] <- NA
final$ratio[(final$ratio > 0.50) & (final$sizw == 4)] <- NA
final$ratio[(final$ratio > 0.5 ) & (final$sizw == 5)] <- NA
final$ratio[(final$ratio > 0.55333333) & (final$sizw == 6)] <- NA
final$ratio[(final$ratio > 0.5714286) & (final$sizw == 7)] <- NA
final$ratio[(final$ratio >  0.7083333) & (final$sizw == 12)] <- NA
final$ratio[(final$ratio >  0.7631579) & (final$sizw == 19)] <- NA

```


## Analyses & Descriptive statistics

# Subset Dataset for percentenge estimates of mixed disturbence types, and unknowns

```{r, echo=TRUE, message=FALSE, warning=FALSE}

unknowns <- final[grep("Unknown", final$dist_name) ,]   
no_unknowns <- dplyr::anti_join(final, unknowns, by = "dist_name") 
mixed_disturbence <- final[grep(",", final$dist_name), ]
single_disturbence <- dplyr::anti_join(final, mixed_disturbence, by = "dist_name")

single_disturbence <- na.omit(single_disturbence)

no_unknowns_mixed_disturbence <- dplyr::anti_join(mixed_disturbence, unknowns, by = "dist_name") 
no_unknowns_single_disturbence <- dplyr::anti_join(single_disturbence, unknowns, by = "dist_name")
unknown_only <- dplyr::anti_join(unknowns, mixed_disturbence, by = "dist_name")


disturbences_names <- c("Unknown","Other Mechanical","Prescribed Fire", "Wildfire", "Thinning","Mastication","Herbicide","Clearcut", "Wildland Fire") # These are the disturbences that are common between 4 ecoregions

## Set up common color schemes 

disturbence_colors <- c('#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6')
eco_region_colors <- c('#df65b0', '#67001f', '#081d58','#7fcdbb') # Oregon then Florida

state_colors <- c('#980043', "#225ea8")
```







## MLE Curve fitting

The Modified Michaelis Menten curve was chosen based on it's ability to match the null-model data. Other MLE curves considered are in the Draft of Likelihood file. Curves were compared excluding single, double, and triple pixels. 


```{r, echo=TRUE, message=FALSE, warning=FALSE}

## Function defining the modifide Michaelis Menten curve
ic=c(4,1,1,1)
MMLnLpower  <- function(beta, ratio, sizw){  ## define likelihood
  LL = -sum(dnorm(ratio,(beta[2]*(sizw^beta[3]))/(beta[1]+(sizw^beta[3])),beta[4], log = TRUE))
  print(LL)
  if(!is.finite(LL)) return(1000)
  return(LL)
}
```



## Sensititvity
# State-level hierarchy 

```{r, echo=TRUE, message=FALSE, warning=FALSE}

## Null
state_to_null <- function(initial, method){
   
   initial <- as.data.frame(initial)
   rows <- dim(initial)[1]
   results <- list()
   iterator <- 0
   
for(i in 1:length(method)){
  for(j in 1:rows){

ic= as.vector(initial[j,] )
null_model_conditional <- single_disturbence$sizw >3 & single_disturbence$dist_name %in% disturbences_names 
all_param <- optim(ic,MMLnLpower,method= method[i], ratio = single_disturbence[null_model_conditional,]$ratio, sizw = single_disturbence[null_model_conditional,]$sizw) 

## Oregon and Florida
oregon_model_conditional <- null_model_conditional &  single_disturbence$state =="OR"
oregon_param <- optim(ic,MMLnLpower,method= method[i], ratio = single_disturbence[ oregon_model_conditional,]$ratio, sizw = single_disturbence[oregon_model_conditional,]$sizw)


florida_model_conditional <- null_model_conditional &  single_disturbence$state =="FL"
florida_param <- optim(ic,MMLnLpower,method= method[i],ratio = single_disturbence[florida_model_conditional,]$ratio, sizw = single_disturbence[florida_model_conditional,]$sizw)

## Check assumptions
check_if_valid_subset <- length(single_disturbence[florida_model_conditional,]$ratio) + length(single_disturbence[oregon_model_conditional,]$ratio) == length(single_disturbence[null_model_conditional,]$ratio)

check_if_converge <- florida_param$convergence == 0 & oregon_param$convergence == 0 & all_param$convergence == 0


## Compare? 
dev.null <- 2*all_param$value         ## null model
dev.tmt  <- 2*oregon_param$value + 2*florida_param$value      
LR       <- dev.null - dev.tmt        ## Likelihood ratio
pval     <- 1 - pchisq(LR,4)

## iterate
iterator <- iterator + 1 
print(iterator)
### Result Object ###

## Sensitivity to optimization
#results <- as.matrix(results)
results$ic[iterator] <-  paste(ic, collapse = ',')
results$method[iterator] <- method[i]
results$pval[iterator] <- pval
results$null_l[iterator] <- 2*all_param$value 
results$tmt_l[iterator] <- 2*oregon_param$value + 2*florida_param$value

## Herarchy-level parameters
results$null_param[iterator] <-  paste( all_param$par, collapse = ',')
results$oregon_param[iterator] <- paste( oregon_param$par, collapse = ',')
results$florida_param[iterator] <- paste(florida_param$par, collapse = ',')

## Check for errors
results$all_converge[iterator] <- check_if_converge
results$valid_subset[iterator] <- check_if_valid_subset

  }
}
   results <- as.data.frame(results)
   print(results)
return(results)
 }

initial <- rbind(c(0,0,0,0),c(2,1,0.5,0.5) , c(1,0.5,0.01,0.01), c(30, 2, 4, 4))

method <- c("BFGS", "Nelder-Mead","SANN" )
test <- NA
test <- state_to_null(initial, method)

dataframe_from_optim <- test


```


## Ecoregion within state

```{r}

eco_to_state <- function(initial, method, tmt_l){
  
   initial <- as.data.frame(initial)
   rows <- dim(initial)[1]
   results <- list()
   iterator <- 0

## create object of all OR and FL parameters
# oregon_param <- list()
# for (i in seq_along(oregon_row)){
# tmp <- strsplit(as.vector(oregon_row[i]), split = ",")
# tmp <- unlist(tmp)
# oregon_param$par[i] <- tmp
# }
# 
# florida_param <- list()
# for (i in seq_along(florida_row)){
# tmp <- strsplit(as.vector(florida_row[i]), split = ",")
# tmp <- unlist(tmp)
# florida_param$par[i] <- tmp
# }


for(i in 1:length(method)){
  for(j in 1:rows){

ic= as.vector(initial[j,] )

## Conditionals 
null_model_conditional <- single_disturbence$sizw >3 & single_disturbence$dist_name %in% disturbences_names 
conditional_fl_8_3  <- null_model_conditional & single_disturbence$state =="FL" & single_disturbence$eco_II == "8.3" 
conditional_fl_8_5 <- null_model_conditional &  single_disturbence$state =="FL" & single_disturbence$eco_II == "8.5" 
conditional_or_6_2 <- null_model_conditional &  single_disturbence$state =="OR" & single_disturbence$eco_II == "6.2" 
conditional_or_7_1 <- null_model_conditional &  single_disturbence$state =="OR" & single_disturbence$eco_II == "7.1" 


fl_8_3 <- optim(ic,MMLnLpower,method= method[i], ratio = single_disturbence[conditional_fl_8_3,]$ratio, sizw = single_disturbence[conditional_fl_8_3,]$sizw)
fl_8_5 <- optim(ic,MMLnLpower,method= method[i], ratio = single_disturbence[ conditional_fl_8_5,]$ratio, sizw = single_disturbence[conditional_fl_8_5,]$sizw)

or_6_2 <- optim(ic,MMLnLpower,method= method[i], ratio = single_disturbence[conditional_or_6_2,]$ratio, sizw = single_disturbence[conditional_or_6_2,]$sizw)
or_7_1 <- optim(ic,MMLnLpower,method= method[i], ratio = single_disturbence[conditional_or_7_1,]$ratio, sizw = single_disturbence[conditional_or_7_1,]$sizw)


## Check assumptions
 fl_subset <- length(single_disturbence[florida_model_conditional,]$ratio) == (length(single_disturbence[conditional_fl_8_3 ,]$ratio) + length(single_disturbence[conditional_fl_8_5 ,]$ratio))
 
 or_subset <- length(single_disturbence[oregon_model_conditional,]$ratio) == (length(single_disturbence[conditional_or_6_2 ,]$ratio) + length(single_disturbence[conditional_or_7_1 ,]$ratio))
 
 print(paste("Valid subset?", (fl_subset & or_subset)))
 check_if_valid_subset <- fl_subset & or_subset

check_if_converge <- florida_param$convergence == 0 & oregon_param$convergence == 0 & all_param$convergence == 0

for( n in seq_along(tmt_l)){ ## Compare to different L values from previous function 

## Compare? 
    dev.null <- tmt_l[n]     ## tmt from previous analysis MUCH EASIER IF PASSED
    dev.tmt  <- 2*fl_8_3$value + 2*fl_8_5$value + 2*or_6_2$value + 2*or_7_1$value  # 8 params in the null, 16 - 4
    LR       <- dev.null - dev.tmt        ## Likelihood ratio
    pval     <- 1 - pchisq(LR,8)
    pval 
    
## iterate
iterator <- iterator + 1 
print(iterator)

### Result Object ###

## Sensitivity to optimization
#results <- as.matrix(results)
results$ic[iterator] <-  paste(ic, collapse = ',')
results$method[iterator] <- method[i]
results$pval[iterator] <- pval
results$null_l[iterator] <- dev.null
results$tmt_l[iterator] <- dev.tmt

## Herarchy-level parameters
results$null_param[iterator] <-  paste( all_param$par, collapse = ',')
results$oregon_param[iterator] <- paste( oregon_param$par, collapse = ',')
results$florida_param[iterator] <- paste(florida_param$par, collapse = ',')

## Check for errors
results$all_converge[iterator] <- check_if_converge
results$valid_subset[iterator] <- check_if_valid_subset

    }
  }
}
   results <- as.data.frame(results)
   print(results)
return(results)
 }

initial <- rbind(c(0,0,0,0),c(2,1,0.5,0.5) , c(1,0.5,0.01,0.01), c(30, 2, 4, 4))

method <- c("BFGS", "Nelder-Mead","SANN" )
test <- NA
eco_to_state_output <- eco_to_state(initial, method)


```


# Metrics 

## Plotting parameters for visual comparison 

```{r}
conditional_list <- list(null_model_conditional, null_model_conditional & single_disturbence$state == "FL", null_model_conditional & single_disturbence$state == "OR" )

plot_params <- function (dataframe_from_optim, conditional_list) {
  
  names <- names(dataframe_from_optim)
  line_number <- length(grep("param", names))
  just_params <- dataframe_from_optim[,grep("param", names)]
  names <- names(just_params)
  
  ## Split params out of text and into seperate lines 
  param_list <- list()
  #names(param_list) <- c("beta", "alpha", "c", "sigma_sq", "line_name")
  just_params <- as.matrix(just_params)

  iterator <- 0
  for(i in 1:line_number){
    for(j in 1:length(just_params[,1])){
      
      iterator <- iterator + 1
      tmp <- strsplit(as.vector(just_params[j, i]), split = ",")
      tmp <- unlist(tmp)
      
      param_list$beta[iterator] <- tmp[1]
      param_list$alpha[iterator] <- tmp[2]
      param_list$c[iterator] <- tmp[3]
      param_list$sigma_sq[iterator] <- tmp[4]
      param_list$line_name[iterator] <- names[i]
      
    }
  }
  
  param_list <- as.data.frame(param_list)
  param_list <- droplevels(param_list)
  
  # Make a seperate color for every line
  colors <- brewer.pal(line_number, "Accent")
  
  # Check that there is a conditional for every line
  if(length(conditional_list) != line_number){
    print("Error: conditional list should match number of seperate parameters")
    break
  }else{
    print("Nice!")
  }
  
for(i in 1:line_number){
  length <- length(single_disturbence[conditional_list[[i]],]$sizw)
length <- length + 1
seq <- c(2:length)
seq[length(seq)] <- max(single_disturbence[conditional_list[[i]],]$sizw)
lower <- lower_bound_ratios(seq)
upper <- upper_bound_ratios(seq)

### State based figures
plot <- single_disturbence[conditional_list[[i]],] %>%
ggplot(aes(sizw, ratio), show.legend = TRUE) +
  geom_hex() + 
  geom_line(aes(x =seq  , y = (upper )), color = "black")+
  geom_line(aes(x =seq , y = (lower )), color = "black")

  for(j in 1:length(just_params[,1])) {
  plot <- plot + geom_line(aes(x = seq, y = ( param_list$alpha[j]*seq^param_list$c[j])/(param_list$beta + seq^param_list$c[j] ), color = colors[i]))
  }
  
  plot <- plot + 
scale_x_continuous(trans="log") +
scale_fill_gradient(trans = "log", breaks = c(1,10,100, 500),  low = "#636363", high = "#bdbdbd") +
   theme(panel.background = element_blank(),
      axis.text.x = element_text(size=14),
      axis.text.y = element_text(size=14), 
      legend.title = element_blank()
      ) + 
scale_x_log10(
   breaks = scales::trans_breaks("log10", function(x) 10^x),
   labels = scales::trans_format("log10", scales::math_format(10^.x))
 )+ 
  xlab("Area ha") +
  ylab("Interior / Total ratio")+ 
  ggtitle(names[i])+
  theme(panel.background = element_blank())
  
  print(plot)
}
  
}


plot_params(dataframe_from_optim = dataframe_from_optim , conditional_list = conditional_list)


```




