---
title: "Spatial Adjactentcy Disterbence type ratios"
output: html_notebook
---


Loading up LANDFIRE disturbence products: 

```{r, echo= TRUE}
library(ncdf4)
library(raster)
library(rgdal)
library(RColorBrewer)
library(RArcInfo)
library(tidyverse)
library(xml2)
library(igraph)


```
(ALL CASES ARE ROOK'S CASE NOTE QUEEN'S CASE OR BISHOP"S CASE")

*NOTE* Mike defines a vertex by the number of pixes in contact with this edge, so if two pixels are touching, it's two verticies, even if they touch one anouther. The difference is, if it's just one pixel touching an vertex, it's an edge, and if it's two pixels, it's an interior vertex. 


```{r}

## Double checking how the area function works
r <- raster(ncol=5, nrow=5)
values(r) <- c(NA,NA,NA,1,NA,
               1,1,1,1,NA,
               NA,1,1,1,NA,
               NA,1,1,1,NA,
               NA,NA,NA,NA,NA)

plot(r)
bound_r <- r
bound_r <- boundaries(r, type = "outer", directions = 4, classes= FALSE)

plot(bound_r)
#zoom(bound_r)

#Find the cell numbers for boundary
tmp_bound_r<-values(bound_r)
tmp_bound_r[tmp_bound_r ==0] <- NA

Adjacent <- cbind(tmp_bound_r, 1:ncell(bound_r))
Adjacent <- na.omit(Adjacent)

# Find the cell numbers for the disturbence itself
r_clump <- cbind(values(r), 1:ncell(r))
r_clump <- na.omit(r_clump)

### Note, to test this, I need a simpler example. 
touching<-adjacent(r, cells = r_clump[,2] ,directions = 4, target = Adjacent[,2], pairs = FALSE)

touching #Everthing I wanted, except for some reason lists 6 and 10? Seems like a wrap-around effect. Could just force a extra frame of NA's to prevent

## Double checking that an extra frame of NA's will solve this problem
s <- raster(ncol=6, nrow=5)
values(s) <- c(NA,NA,NA,1,NA,NA,
               NA,1,1,1,1,NA,
               NA,NA,1,1,1,NA,
               NA,NA,1,1,1,NA,
               NA,NA,NA,NA,NA,NA)

plot(s)
bound_s <- s
bound_s <- boundaries(s, type = "outer", directions = 4, classes= FALSE)

plot(bound_s)


#Find the cell numbers for boundary
tmp_bound_s<-values(bound_s)
tmp_bound_s[tmp_bound_s ==0] <- NA

Adjacent <- cbind(tmp_bound_s, 1:ncell(bound_s))
Adjacent <- na.omit(Adjacent)

# Find the cell numbers for the disturbence itself
s_clump <- cbind(values(s), 1:ncell(s))
s_clump <- na.omit(s_clump)

### Note, to test this, I need a simpler example. 
touching<-adjacent(s, cells = s_clump[,2] ,directions = 4, target = Adjacent[,2])

touching


```
OK: So this brings up an interesting issue: Wrap-around values. So, the 5 is touching the 6 in this example, which wouldn't be allowed in Mike and I's analysis. Would be rare, but need a check/ account for. 


## Implementing Functions

**Outer Edge**
```{r}
get_outer_edges <- function(r, directions = 4, classes = FALSE, FRAME = TRUE, ...){
  
  outer_edges<- list()
  
  ## Check that the raster uses NA's as background state
 has_NA <-NA %in% values(r)
  
 # Make indexable matrix of r
 index_r <- cbind( values(r), seq(1:ncell(r)))
 
  if( ! has_NA ){
    print("WARNING, this raster seems to not use NA's as background state. This could mean that the number of edge cells is inflated if value-cells are on a boarder of the raster ")
  }
  
  ## Give frame of NA's
  if(has_NA & FRAME){
    
    r_ncol <- ncol(r)
    #r_nrow <- nrow(r)
    n_ncell <- (ncol(r) + 2) * (nrow(r) + 2)
    
    #Make new values vector
    n_vals <- rep(NA, n_ncell)
    n_ncol <- ncol(r) + 2
    mult_row <- 0
    
    for(i in 1:ncell(r)){
      
      new_index <- n_ncol + 1 + mult_row + index_r[i,2]
      n_vals[new_index] <- index_r[i,1]
      
      if(((new_index + 1) %% n_ncol) == 0){
        mult_row<- mult_row+2
      }
      
    }
  
    
    r<- raster(nrows = r_nrow+2, ncol = r_ncol +2, vals = as.matrix(n_vals))
  }
  
  
  ## Get outer boundary
  bound_r <- boundaries(r, type = "outer", directions = 4, classes= classes)
  
  ## account for every time the outher boundary touches the raster itself
  
    ## Prep the indexes
    new_index_r <- cbind( values(r), seq(1:ncell(r)))
    new_index_r <- na.omit(new_index_r) ## need a new index
  
    tmp_bound_r<-values(bound_r)
    tmp_bound_r[tmp_bound_r ==0] <- NA

    Adjacent <- cbind(tmp_bound_r, 1:ncell(bound_r))
    Adjacent <- na.omit(Adjacent)
    
    ## get the adjacentcy 
    touching<-adjacent(r, cells = new_index_r[,2] ,directions = 4, target =    Adjacent[,2])
    
    outer_edges$cells <- touching
    outer_edges$number <- length(touching[,1])
    outer_edges$size <- length(new_index_r[,2])
    
    return(outer_edges)
}

```

** Testing get_outer_edges on simple cases **

```{r}
r <- raster(ncol=5, nrow=5)
values(r) <- c(NA,NA,NA,NA,NA,
               NA,NA,NA,NA,NA,
               NA,1,NA,NA,NA,
               NA,1,NA,NA,NA,
               NA,NA,NA,NA,NA)

get_outer_edges(r)


values(r) <- c(NA,NA,NA,NA,NA,
               NA,1,1,1,NA,
               NA,1,NA,1,NA,
               NA,1,1,1,NA,
               NA,NA,NA,NA,NA)
get_outer_edges(r)

```

** Interior Vertices **
NOTE:  can get internal vertieces (by mike's definition) by setting cells to just the values, and target to those same values

```{r}

get_interior_vertices<- function(r, directions = 4, classes = FALSE, FRAME = TRUE, ...){
  
  interior_vertices<- list()
  
  ## Check that the raster uses NA's as background state
 has_NA <-NA %in% values(r)
  
 # Make indexable matrix of r
 index_r <- cbind( values(r), seq(1:ncell(r)))
 
  if( ! has_NA ){
    print("WARNING, this raster seems to not use NA's as background state. This could mean that the number of interior_vertices is inflated if value-cells are on a boarder of the raster ")
  }
  
  ## Give frame of NA's
  if(has_NA & FRAME){
    
    r_ncol <- ncol(r)
    #r_nrow <- nrow(r)
    n_ncell <- (ncol(r) + 2) * (nrow(r) + 2)
    
    #Make new values vector
    n_vals <- rep(NA, n_ncell)
    n_ncol <- ncol(r) + 2
    mult_row <- 0
    
    for(i in 1:ncell(r)){
      
      new_index <- n_ncol + 1 + mult_row + index_r[i,2]
      n_vals[new_index] <- index_r[i,1]
      
      if(((new_index + 1) %% n_ncol) == 0){
        mult_row<- mult_row+2
      }
      
    }
  
    
    r<- raster(nrows = r_nrow+2, ncol = r_ncol +2, vals = as.matrix(n_vals))
  }
  
  
  
  ## account for every time the outher boundary touches the raster itself
  
    ## Prep the indexes
    new_index_r <- cbind( values(r), seq(1:ncell(r)))
    new_index_r <- na.omit(new_index_r) ## need a new index
  
    
    ## get the adjacentcy 
    touching<-adjacent(r, cells = new_index_r[,2] ,directions = 4, target =   new_index_r[,2])
    
    interior_vertices$cells <- touching
    interior_vertices$number <- length(touching[,1])
    interior_vertices$size <- length(new_index_r[,2])
    
    return(interior_vertices)
  
}

```

** testing get_interior_vertices on simple cases **
```{r}
r <- raster(ncol=5, nrow=5)
values(r) <- c(NA,NA,NA,NA,NA,
               NA,NA,NA,NA,NA,
               NA,1,NA,NA,NA,
               NA,1,NA,NA,NA,
               NA,NA,NA,NA,NA)

get_interior_vertices(r)


values(r) <- c(NA,NA,NA,NA,NA,
               NA,1,1,1,NA,
               NA,1,NA,1,NA,
               NA,1,1,1,NA,
               NA,NA,NA,NA,NA)
get_interior_vertices(r)

```

## Edge to interior ratio function

```{r}
edge_to_interior<- function(r, ...){
  
  results <- list()  

  outer<- get_outer_edges(r)
  inner<- get_interior_vertices(r)
  
  if(outer$size <= 1){
    stop ("Size of disturbence is a single pixel. Will result in a 4/0.")
  }
  
  results$ratio <- outer$number/inner$number
  results$size <- outer$size
  return()
}
```

** testing on cases from the notes**
```{r}
r <- raster(ncol=5, nrow=5)
values(r) <- c(NA,NA,NA,NA,NA,
               NA,NA,NA,NA,NA,
               NA,1,1,NA,NA,
               NA,1,1,NA,NA,
               NA,NA,NA,NA,NA)

edge_to_interior(r)


values(r) <- c(NA,NA,NA,NA,NA,
               NA,1,1,1,NA,
               NA,NA,NA,NA,NA,
               NA,NA,NA,NA,NA,
               NA,NA,NA,NA,NA)
edge_to_interior(r)

```


Some issues and limitations to disscuss: 
1. All this is implemented for rook's case, not queen's case. How do we feel about this? 
2. How do we parse disturbences? By event or by spatially contigious "splotches"? 
     - very little (if any?) documentation on events 
     - In our current scheme, things that viasually would look like a coninious dsturbence might get filtered out if conected along a diagonal
     - also could imagine a scanario where a larger fire becomes smaller less connected fires effects of larger fire wouldn't be captured
     - This brings us back to a wider question of "What do we really expect the edge to interior ratio to charecterise?"
3. I have beed lumping together all fire catagories. What catagories should I break fire into? 
4. we also can't work with disturbences that are a pixel or less. And that is the majority of disturbences in the landfire dataset. (I have a mock-up example chart with real data) 

## With Landfire

```{r}

test <- raster("/Users/tess/Documents/work/LANDFIRE/Geo_tiff/lf06628962_US_DIST2000/US_DIST2000\\US_DIST2000.tif")

csv<-read.csv("/Users/tess/Documents/work/LANDFIRE/disturb2000.csv")
csv_fire<-csv[grep("*ire*", csv$Dist_Type),]


### Attempt to subset just fire
fire<-c(csv_fire$Value, 0)
tmp<-getValues(test)
tmp[!(tmp %in% fire)] <- NA
tmp[tmp == 0] <- NA
tmp[tmp > 0] <-1
#temp<-as.matrix(temp)
fire_only <- test
values(fire_only) <- tmp
rm(tmp)

fire_clump<-clump(fire_only, gaps = FALSE, directions = 4)
#clump_1<- fire_clump
#tmp<- getValues(fire_clump)
#tmp[ tmp != 11]<- NA
#values(clump_1) <- tmp
#rm(tmp)

plot(fire_clump == 13)

## Try a clump-based loop
clump_num <- unique(fire_clump)
clump_num[clump_num <= 10] <- NA
clump_num <- na.omit(unique(fire_clump))

resuts<- list()
for ( i in seq_along(clump_num)){

  results[i] <- edge_to_interior(fire_clump == i)
}


```

NOTE TO SELF: Right now I don't actually match Mike's slides. He does a int/ int + edge. Gotta fix, and will kinda change my "/0" issue. 